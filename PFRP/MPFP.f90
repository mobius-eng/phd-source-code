MODULE MPFP

USE ENV, ONLY: WREAL, WINT
USE NEWTON, ONLY: NEWTON_PROBLEM, NEWTON_SOLVE => SOLVE, &
    FUN_WITH_DERIV

IMPLICIT NONE

PRIVATE

PUBLIC RUN, MASS_BALANCE

CONTAINS

SUBROUTINE STEP(C, X, FN, NPROB)

TYPE(NEWTON_PROBLEM(*)) :: NPROB
REAL(WREAL), DIMENSION(0:NPROB%N), INTENT(INOUT) :: C, X
PROCEDURE(FUN_WITH_DERIV) :: FN

CALL NEWTON_SOLVE(C, X, NPROB, FN)

END SUBROUTINE STEP



SUBROUTINE RUN(C, X, ALPHA, FN, K, R, TOL, MAXITER, N, M, GSITER, NEWTITER, ERR)

REAL(WREAL), DIMENSION(0:N, 0:M), INTENT(INOUT) :: C, X
REAL(WREAL), INTENT(IN) :: ALPHA, R, K, TOL
PROCEDURE(FUN_WITH_DERIV) :: FN
INTEGER(WINT), INTENT(IN) :: N, M, MAXITER
INTEGER(WINT), INTENT(OUT) :: GSITER, NEWTITER
REAL(WREAL) :: ERR

TYPE(NEWTON_PROBLEM(N)) :: NPROB
INTEGER(WINT) :: I

CALL NPROB%INIT(ALPHA, 1.0_WREAL, K, R, TOL, MAXITER)

DO I=1,M
    C(:,I) = C(:,I-1)
    X(:,I) = X(:,I-1)
    CALL STEP(C(:,I), X(:,I), FN, NPROB)
    IF (NPROB%ERR < 0) THEN
        RETURN
    END IF    
END DO

GSITER = NPROB%LIN_PROBLEM%ITER
NEWTITER = NPROB%ITER
ERR = NPROB%ERR

END SUBROUTINE


PURE FUNCTION TRAPEZOID(Y, H) RESULT (S)

REAL(WREAL), DIMENSION(0:), INTENT(IN) :: Y
REAL(WREAL), INTENT(IN) :: H
REAL(WREAL) :: S

INTEGER(WINT) :: N

N = SIZE(Y)
S = SUM(Y)
S = H*(S - (Y(0) + Y(N-1)) / 2)
END FUNCTION


SUBROUTINE MASS_BALANCE(C, X, FN, K, R, CIN, COUT, CEND, CCONS, CERR, N, M)

REAL(WREAL), INTENT(IN), DIMENSION(0:N,0:M) :: C, X
PROCEDURE(FUN_WITH_DERIV) :: FN
REAL(WREAL), INTENT(IN) :: K, R
REAL(WREAL), INTENT(OUT) :: CIN, COUT, CEND, CCONS, CERR
INTEGER(WINT), INTENT(IN) :: N, M

REAL(WREAL), DIMENSION(:, :), ALLOCATABLE :: FVALS

INTEGER(WINT) :: I, J
REAL(WREAL) :: H

ALLOCATE (FVALS(0:N, 0:M))

H = K / R

CIN = K * M
COUT = TRAPEZOID(C(N,:), K)
CEND = TRAPEZOID(C(:, M), H)

CALL FILLF
CCONS = SUM(FVALS) - 0.5*(SUM(FVALS(0,:)) + SUM(FVALS(N,:)) + SUM(FVALS(:,0)) + SUM(FVALS(:,M)))
CCONS = CCONS * H * K

CERR = CIN - COUT - CEND - CCONS


    CONTAINS
    
    
    SUBROUTINE FILLF
    
    INTEGER(WINT) :: I, J
    REAL(WREAL) :: FC, FX
    
    DO CONCURRENT (J=0:M)
        DO CONCURRENT (I=0:N)
            CALL FN(C(I, J), X(I, J), FVALS(I, J), FC, FX)
        END DO
    END DO
    
    END SUBROUTINE

END SUBROUTINE

END MODULE