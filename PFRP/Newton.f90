MODULE NEWTON

USE ENV
USE GAUSS_SEIDEL, ONLY: GS_PROBLEM, GS_SOLVE => SOLVE

IMPLICIT NONE

PRIVATE

TYPE, PUBLIC :: NEWTON_PROBLEM(N)
    INTEGER(WINT), LEN :: N
    TYPE(GS_PROBLEM(N)) :: LIN_PROBLEM
    REAL(WREAL), DIMENSION(0:N) :: BC0, BX0, F, FC, FX, C0
    REAL(WREAL) :: ALPHA, K, V, R
    REAL(WREAL) :: TOL, ERR
    INTEGER(WINT) :: MAXITER, ITER
CONTAINS
    PROCEDURE, PASS(SELF) :: INIT => PROBLEM_INIT
END TYPE NEWTON_PROBLEM

INTERFACE
    PURE SUBROUTINE FUN_WITH_DERIV(C, X, F, FC, FX)
    IMPORT :: WREAL
    REAL(WREAL), INTENT(IN) :: C, X
    REAL(WREAL), INTENT(OUT) :: F, FC, FX
    END SUBROUTINE FUN_WITH_DERIV
END INTERFACE

PUBLIC :: SOLVE, FUN_WITH_DERIV

CONTAINS

SUBROUTINE PROBLEM_INIT(SELF, ALPHA, V, K, R, TOL, MAXITER)

CLASS(NEWTON_PROBLEM(*)), INTENT(INOUT) :: SELF
REAL(WREAL), INTENT(IN) :: ALPHA, V, K, R, TOL
INTEGER(WINT) :: MAXITER

SELF%ALPHA = ALPHA; SELF%V = V; SELF%K = K; SELF%R = R; SELF%TOL = TOL
SELF%BX0(0) = -3.0_WREAL
SELF%MAXITER = MAXITER
SELF%ITER = 0
SELF%ERR = 0.0_WREAL
SELF%LIN_PROBLEM%TOL = TOL
SELF%LIN_PROBLEM%MAXITER = MAXITER
SELF%LIN_PROBLEM%ERR = 0.0_WREAL
SELF%LIN_PROBLEM%ITER = 0
RETURN

END SUBROUTINE PROBLEM_INIT


SUBROUTINE STEP(C, X, COEFFS, BC0, BX0, F, FC, FX, ALPHA, K, V, R)

TYPE(GS_PROBLEM(*)), INTENT(INOUT) :: COEFFS
REAL(WREAL), DIMENSION(0:COEFFS%N), INTENT(INOUT) :: C, X
REAL(WREAL), DIMENSION(0:COEFFS%N), INTENT(IN) :: BC0, BX0, F, FC, FX
REAL(WREAL), INTENT(IN) :: ALPHA, K, V, R

COEFFS%ACM(1) = 2 / (2 + V*R + K *FC(1))
COEFFS%ACM(2:) = 4.0_WREAL / (4 + 3*V*R + 2*K*FC(2:))

COEFFS%AC2(2:) = -V*R/4

COEFFS%AC1(1) = V*R/2
COEFFS%AC1(2:) = V*R

COEFFS%ACX(1:) = -K*FX(1:)/2

COEFFS%AXM(:) = 2 / (2 - ALPHA*K*FX(:))

COEFFS%AXC(:) = ALPHA*K*FC(:) / 2

COEFFS%BC(:) = BC0 - (K/2)*(F - FC * C - FX * X)

COEFFS%BX(:) = BX0 + (ALPHA*K/2) * (F - FC * C - FX * X)

CALL GS_SOLVE(C, X, COEFFS)

END SUBROUTINE STEP


SUBROUTINE SOLVE(C, X, PROB, FN)

TYPE(NEWTON_PROBLEM(*)), INTENT(INOUT) :: PROB
REAL(WREAL), DIMENSION(0:PROB%N), INTENT(INOUT) :: C, X
PROCEDURE(FUN_WITH_DERIV) :: FN

REAL(WREAL) :: VR
INTEGER(WINT) :: I
INTEGER(WINT) :: ITER

! Fill F, FC and FX on current approximation
CALL FILLF

! Fill in const part of RHS

VR = PROB%V * PROB%R

PROB%BC0(1) = (VR * C(0) + (2 - VR) * C(1) - PROB%K * PROB%F(1)) / 2
PROB%BC0(2:) = ( &
    -VR * C(0:PROB%N-2) + 4 * VR * C(1:PROB%N-1) + (4 - 3 * VR) * C(2:) &
    - 2 * PROB%K * PROB%F(2:)) / 4

PROB%BX0(:) = X + (PROB%ALPHA * PROB%K / 2) * PROB%F

DO ITER = 1, PROB%MAXITER
    PROB%C0(:) = C
    CALL STEP(C, X, PROB%LIN_PROBLEM, PROB%BC0, PROB%BX0, PROB%F, PROB%FC, PROB%FX, &
        PROB%ALPHA, PROB%K, PROB%V, PROB%R)
    
    IF (PROB%LIN_PROBLEM%ERR < 0) THEN
        PROB%ERR = -1.0_WREAL
        EXIT
    END IF
    
    PROB%ERR = COMPUTE_ERROR(PROB%C0, C)
    
    IF (PROB%ERR < PROB%TOL) THEN
        PROB%ITER = PROB%ITER + ITER
        RETURN
    END IF
    CALL FILLF
END DO

IF (PROB%ERR > 0) PROB%ERR = -2.0

RETURN
    

    CONTAINS

    SUBROUTINE FILLF
    
    INTEGER(WINT) :: I
    
    DO CONCURRENT (I = 0:PROB%N)
        CALL FN(C(I), X(I), PROB%F(I), PROB%FC(I), PROB%FX(I))
    END DO
    
    END SUBROUTINE FILLF
    
    
    PURE FUNCTION COMPUTE_ERROR(C0, C) RESULT (E)
    
    REAL(WREAL), DIMENSION(:), INTENT(IN) :: C0, C
    REAL(WREAL) :: E
    
    INTEGER(WINT) :: I
    
    E = 0.0_WREAL
    
    DO I = 1, SIZE(C0)
        E = MAX(E, ABS(C0(I)-C(I)))
    END DO
    
    END FUNCTION COMPUTE_ERROR

    
END SUBROUTINE SOLVE

END MODULE NEWTON